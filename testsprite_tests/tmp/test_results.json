[
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "e3d4229c-6b07-4f08-8f2d-710fbd07b06a",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC001-multi profile authentication redirection",
    "description": "Verify that the multi-profile authentication system correctly supports dynamic profile switching and automatically redirects users to the appropriate dashboard based on the selected profile (Gestor, Hospital, Médico, Paciente).",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30  # seconds\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\n# Profiles and their expected dashboard paths for redirection\nPROFILE_DASHBOARD_PATHS = {\n    \"Gestor\": \"/dashboard/gestor\",\n    \"Hospital\": \"/dashboard/hospital\",\n    \"Médico\": \"/dashboard/medico\",\n    \"Paciente\": \"/dashboard/paciente\",\n}\n\ndef create_demo_user():\n    \"\"\"\n    Uses the Supabase edge function to create a demo user with multiple profiles.\n    Returns the user credentials and user ID.\n    \"\"\"\n    url = f\"{BASE_URL}/edge-functions/create-demo-user\"\n    try:\n        response = requests.post(url, timeout=TIMEOUT)\n        response.raise_for_status()\n        return response.json()  # Expecting at least { \"email\": ..., \"password\": ..., \"user_id\": ... }\n    except (RequestException, Timeout) as e:\n        raise RuntimeError(f\"Failed to create demo user: {e}\")\n\ndef delete_user(user_id, jwt_token):\n    \"\"\"\n    Deletes a user by ID using the authentication service or user management API.\n    Assumes an endpoint DELETE /users/{user_id} with JWT auth.\n    \"\"\"\n    url = f\"{BASE_URL}/api/users/{user_id}\"\n    headers = HEADERS.copy()\n    headers[\"Authorization\"] = f\"Bearer {jwt_token}\"\n    try:\n        response = requests.delete(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except (RequestException, Timeout):\n        # Try best effort, do not fail test on cleanup\n        pass\n\ndef authenticate_user(email, password):\n    \"\"\"\n    Authenticates user credentials to receive a JWT token.\n    Expects POST /auth/login with JSON body {email, password} returning {access_token, refresh_token, profiles}\n    \"\"\"\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    try:\n        response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        if \"access_token\" not in data or \"profiles\" not in data:\n            raise RuntimeError(\"Authentication response missing required fields.\")\n        return data\n    except (RequestException, Timeout) as e:\n        raise RuntimeError(f\"Authentication failed: {e}\")\n\ndef switch_profile(token, profile):\n    \"\"\"\n    Switches the active profile using an API endpoint.\n    POST /api/auth/switch-profile with JSON {profile} and Authorization header.\n    Returns redirect URL in response JSON {redirect_url}\n    \"\"\"\n    url = f\"{BASE_URL}/api/auth/switch-profile\"\n    headers = HEADERS.copy()\n    headers[\"Authorization\"] = f\"Bearer {token}\"\n    payload = {\"profile\": profile}\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        if \"redirect_url\" not in data:\n            raise RuntimeError(\"Profile switch response missing redirect_url.\")\n        return data[\"redirect_url\"]\n    except (RequestException, Timeout) as e:\n        raise RuntimeError(f\"Profile switch failed for profile '{profile}': {e}\")\n\ndef test_multi_profile_authentication_redirection():\n    demo_user = None\n    jwt_token = None\n    user_id = None\n\n    try:\n        # Step 1: Create demo user with multiple profiles\n        demo_user = create_demo_user()\n        email = demo_user.get(\"email\")\n        password = demo_user.get(\"password\")\n        user_id = demo_user.get(\"user_id\")\n        assert email and password and user_id, \"Demo user response missing required fields.\"\n        \n        # Step 2: Authenticate user to get JWT token and available profiles\n        auth_data = authenticate_user(email, password)\n        jwt_token = auth_data[\"access_token\"]\n        profiles = auth_data[\"profiles\"]  # Expecting list of profile names\n        \n        # Validate all expected profiles exist\n        expected_profiles = set(PROFILE_DASHBOARD_PATHS.keys())\n        user_profiles = set(profiles)\n        assert expected_profiles.issubset(user_profiles), f\"User profiles {user_profiles} do not include all expected {expected_profiles}\"\n        \n        # Step 3 & 4: For each profile, switch profile and validate redirect URL matches expected dashboard\n        for profile in expected_profiles:\n            redirect_url = switch_profile(jwt_token, profile)\n            assert redirect_url.startswith(BASE_URL), f\"Redirect URL does not start with base URL: {redirect_url}\"\n            expected_path = PROFILE_DASHBOARD_PATHS[profile]\n            assert redirect_url.endswith(expected_path), (\n                f\"Redirect URL '{redirect_url}' does not end with expected dashboard path '{expected_path}' for profile '{profile}'\"\n            )\n    finally:\n        # Cleanup: delete demo user if created and JWT token available\n        if user_id and jwt_token:\n            delete_user(user_id, jwt_token)\n\ntest_multi_profile_authentication_redirection()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 26, in create_demo_user\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/edge-functions/create-demo-user\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 122, in <module>\n  File \"<string>\", line 93, in test_multi_profile_authentication_redirection\n  File \"<string>\", line 29, in create_demo_user\nRuntimeError: Failed to create demo user: 404 Client Error: Not Found for url: http://localhost:8080/edge-functions/create-demo-user\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.705Z",
    "modified": "2025-09-17T22:20:35.184Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "999a0a64-d407-480c-be41-591f1b582139",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC002-municipal dashboard kpi display",
    "description": "Test that the municipal dashboard displays updated and functional KPIs and SUS indicators with the correct dark theme and glassmorphism style.",
    "code": "import requests\nimport base64\nimport json\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Dummy credentials for authentication - replace with valid test credentials\nTEST_USER = {\n    \"email\": \"municipal_gestor@test.com\",\n    \"password\": \"TestPass123!\"\n}\n\ndef authenticate(email, password):\n    url = f\"{BASE_URL}/login\"\n    payload = {\"email\": email, \"password\": password}\n    headers = {\"Content-Type\": \"application/json\"}\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        token = data.get(\"access_token\") or data.get(\"token\")\n        assert token, \"Authentication token not found in response\"\n        return token\n    except requests.RequestException as e:\n        raise AssertionError(f\"Authentication request failed: {e}\")\n    except ValueError:\n        raise AssertionError(\"Invalid JSON response during authentication\")\n\ndef get_municipal_dashboard(token):\n    url = f\"{BASE_URL}/dashboard/municipal\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        return response\n    except requests.RequestException as e:\n        raise AssertionError(f\"Municipal dashboard request failed: {e}\")\n\ndef decode_jwt_no_verify(token):\n    # JWT format: header.payload.signature\n    try:\n        payload_part = token.split('.')[1]\n        # Pad base64 string\n        padding = '=' * (-len(payload_part) % 4)\n        payload_bytes = base64.urlsafe_b64decode(payload_part + padding)\n        payload_json = payload_bytes.decode('utf-8')\n        return json.loads(payload_json)\n    except Exception as e:\n        raise AssertionError(f\"JWT token decoding failed: {e}\")\n\ndef test_municipal_dashboard_kpi_display():\n    # Authenticate user to get valid JWT token\n    token = authenticate(TEST_USER[\"email\"], TEST_USER[\"password\"])\n\n    # Validate JWT token structure and expiry\n    payload = decode_jwt_no_verify(token)\n    assert \"exp\" in payload, \"Token missing expiry\"\n    assert payload[\"exp\"] > time.time(), \"Token expired\"\n    # Role or scope validation\n    roles = payload.get(\"roles\") or payload.get(\"role\") or []\n    if isinstance(roles, str):\n        roles = [roles]\n    assert any(role in [\"gestor\", \"municipal_manager\"] for role in roles), \"User role does not have municipal dashboard access\"\n\n    # Request municipal dashboard data\n    response = get_municipal_dashboard(token)\n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        raise AssertionError(\"Response is not valid JSON\")\n\n    # Validate key parts of dashboard response\n    # KPIs\n    kpis = data.get(\"kpis\")\n    assert isinstance(kpis, dict), \"KPIs section missing or not a dict\"\n    assert \"updatedAt\" in data, \"Dashboard data missing update timestamp\"\n    assert isinstance(kpis.get(\"indicators_sus\"), dict), \"SUS indicators missing or invalid\"\n\n    # Validate presence and correctness of key SUS indicators\n    indicators = kpis.get(\"indicators_sus\")\n    essential_indicators = [\n        \"coverage_rate\",\n        \"immunization_index\",\n        \"hospital_admissions\",\n        \"primary_care_score\",\n        \"health_service_access\"\n    ]\n    for indicator in essential_indicators:\n        val = indicators.get(indicator)\n        assert val is not None, f\"Indicator '{indicator}' missing in SUS indicators\"\n        assert isinstance(val, (int, float)), f\"Indicator '{indicator}' must be numeric\"\n\n    # Validate dark theme and glassmorphism style flags (backend flags)\n    ui_config = data.get(\"ui_config\")\n    assert ui_config, \"UI config missing in dashboard data\"\n    # Theme validation\n    theme = ui_config.get(\"theme\")\n    assert theme == \"dark\", f\"Expected theme 'dark', got '{theme}'\"\n    # Glassmorphism effect flag\n    glassmorphism = ui_config.get(\"glassmorphism\")\n    assert isinstance(glassmorphism, bool), \"Glassmorphism flag missing or not boolean\"\n    assert glassmorphism is True, \"Glassmorphism style flag should be true\"\n\n    # Additional schema sanity checks: timestamps, data types\n    updated_at = data.get(\"updatedAt\")\n    assert isinstance(updated_at, str), \"updatedAt should be a string timestamp\"\n    # Optionally parse ISO8601 timestamp\n    from datetime import datetime\n    try:\n        datetime.fromisoformat(updated_at.replace(\"Z\", \"+00:00\"))\n    except Exception:\n        raise AssertionError(\"updatedAt timestamp is not valid ISO8601 format\")\n\n    # Security headers check (common security headers)\n    # Example: check CORS and CSP headers are present\n    security_headers = [\"Content-Security-Policy\", \"X-Content-Type-Options\", \"Strict-Transport-Security\", \"X-Frame-Options\"]\n    for header in security_headers:\n        # header names can vary, ignore case\n        if not any(h.lower() == header.lower() for h in response.headers):\n            # Not all headers may be present, just warn/assert some critical ones:\n            if header in [\"Content-Security-Policy\", \"X-Content-Type-Options\"]:\n                raise AssertionError(f\"Security header '{header}' missing in response\")\n\n\ntest_municipal_dashboard_kpi_display()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 21, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 131, in <module>\n  File \"<string>\", line 57, in test_municipal_dashboard_kpi_display\n  File \"<string>\", line 27, in authenticate\nAssertionError: Authentication request failed: 404 Client Error: Not Found for url: http://localhost:8080/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.711Z",
    "modified": "2025-09-17T22:21:18.561Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "b7528b94-fee7-44c5-9fbf-da1b54d4a391",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC003-hospital dashboard operational indicators",
    "description": "Validate that the hospital dashboard shows accurate operational indicators, bed management data, billing information, and analysis reports.",
    "code": "import requests\nimport time\nimport base64\nimport json\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Assuming we have credentials for hospital admin profile for authentication\nAUTH_CREDENTIALS = {\n    \"username\": \"hospital_admin\",\n    \"password\": \"securepassword123\"\n}\n\ndef authenticate_get_jwt():\n    url = f\"{BASE_URL}/auth/login\"\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = requests.post(url, json=AUTH_CREDENTIALS, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200, f\"Authentication failed with status {resp.status_code}\"\n    json_resp = resp.json()\n    assert \"access_token\" in json_resp, \"No access_token in authentication response\"\n    return json_resp[\"access_token\"]\n\ndef decode_jwt_payload(token):\n    try:\n        _, payload_b64, _ = token.split('.')\n        padding = '=' * (-len(payload_b64) % 4)\n        payload_b64 += padding\n        decoded_bytes = base64.urlsafe_b64decode(payload_b64)\n        payload = json.loads(decoded_bytes)\n        return payload\n    except Exception as e:\n        assert False, f\"Failed to decode JWT payload: {str(e)}\"\n\ndef test_hospital_dashboard_operational_indicators():\n    token = None\n    headers = None\n    try:\n        # Authenticate to get JWT token\n        token = authenticate_get_jwt()\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Accept\": \"application/json\"\n        }\n\n        # 1. Validate Hospital Dashboard Operational Indicators\n        dashboard_url = f\"{BASE_URL}/api/dashboard/hospital/operational-indicators\"\n        resp = requests.get(dashboard_url, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Dashboard API returned {resp.status_code}\"\n        data = resp.json()\n\n        # Check existence and types of key operational indicators\n        expected_keys = [\n            \"bedManagement\",\n            \"billingInfo\",\n            \"analysisReports\",\n            \"operationalMetrics\"\n        ]\n        for key in expected_keys:\n            assert key in data, f\"Missing key '{key}' in dashboard response\"\n\n        # Validate bed management data format\n        beds = data[\"bedManagement\"]\n        assert isinstance(beds, dict), \"bedManagement should be a dictionary\"\n        assert \"totalBeds\" in beds and isinstance(beds[\"totalBeds\"], int), \"totalBeds missing or not integer\"\n        assert \"occupiedBeds\" in beds and isinstance(beds[\"occupiedBeds\"], int), \"occupiedBeds missing or not integer\"\n        assert 0 <= beds[\"occupiedBeds\"] <= beds[\"totalBeds\"], \"occupiedBeds out of valid range\"\n\n        # Validate billing information format\n        billing = data[\"billingInfo\"]\n        assert isinstance(billing, dict), \"billingInfo should be a dictionary\"\n        assert \"totalBilled\" in billing and isinstance(billing[\"totalBilled\"], (int, float)), \"totalBilled missing or invalid\"\n        assert \"pendingPayments\" in billing and isinstance(billing[\"pendingPayments\"], (int, float)), \"pendingPayments missing or invalid\"\n\n        # Validate analysis reports presence\n        reports = data[\"analysisReports\"]\n        assert isinstance(reports, list), \"analysisReports should be a list\"\n        # If reports not empty, check structure of first report\n        if reports:\n            report = reports[0]\n            assert isinstance(report, dict), \"Each report should be a dict\"\n            assert \"reportId\" in report and isinstance(report[\"reportId\"], str), \"reportId missing or invalid\"\n            assert \"title\" in report and isinstance(report[\"title\"], str), \"title missing or invalid\"\n            assert \"generatedAt\" in report, \"generatedAt missing\"\n\n        # Validate operational metrics\n        metrics = data.get(\"operationalMetrics\")\n        assert metrics and isinstance(metrics, dict), \"operationalMetrics missing or invalid\"\n        # Example: check 'averageLengthOfStay' metric\n        avg_los = metrics.get(\"averageLengthOfStay\")\n        assert avg_los is not None and isinstance(avg_los, (int, float)), \"averageLengthOfStay metric missing or invalid\"\n        assert avg_los > 0, \"averageLengthOfStay should be positive\"\n\n        # 2. Test backend database integrations by checking RTD/Supabase health endpoint\n        health_url = f\"{BASE_URL}/api/health\"\n        health_resp = requests.get(health_url, headers=headers, timeout=TIMEOUT)\n        assert health_resp.status_code == 200, f\"Health check returned {health_resp.status_code}\"\n        health_data = health_resp.json()\n        # Check db and external integrations status keys are present\n        for service in [\"database\", \"supabaseAuth\", \"datasusApis\", \"erpIntegration\"]:\n            assert service in health_data, f\"Health status missing {service}\"\n            assert health_data[service] == \"ok\", f\"{service} status not ok: {health_data[service]}\"\n\n        # 3. Security checks: Validate JWT token structure and expiration\n        try:\n            payload = decode_jwt_payload(token)\n            assert \"exp\" in payload, \"JWT token missing expiration\"\n            exp = payload[\"exp\"]\n            now = int(time.time())\n            assert exp > now, \"JWT token expired\"\n        except Exception as e:\n            assert False, f\"JWT token decode error: {str(e)}\"\n\n        # 4. Rate limiting and performance basic check: issue multiple calls under short delay\n        times = []\n        for _ in range(3):\n            start = time.time()\n            r = requests.get(dashboard_url, headers=headers, timeout=TIMEOUT)\n            duration = time.time() - start\n            times.append(duration)\n            assert r.status_code == 200, f\"Dashboard API call failed with status {r.status_code}\"\n\n        avg_response = sum(times) / len(times)\n        assert avg_response < 2, f\"Average response time {avg_response}s exceeds 2s performance requirement\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n    finally:\n        # Optionally, perform logout or cleanup if the API supports it\n        if token and headers:\n            try:\n                requests.post(f\"{BASE_URL}/auth/logout\", headers=headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_hospital_dashboard_operational_indicators()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 137, in <module>\n  File \"<string>\", line 40, in test_hospital_dashboard_operational_indicators\n  File \"<string>\", line 19, in authenticate_get_jwt\nAssertionError: Authentication failed with status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.716Z",
    "modified": "2025-09-17T22:20:58.884Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "8d4beeb2-529b-4bef-bcb8-39e8317d7be9",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC004-erp integration error rate and response time",
    "description": "Ensure that the integration with hospital ERP systems and DATASUS APIs maintains an error rate below 1% and response times under 500ms.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\",\n    \"Content-Type\": \"application/json\"\n}\n\n# Endpoints for ERP integrations and DATASUS APIs as available (simulate checking several)\nERP_ENDPOINTS = [\n    \"/api/erp/philips-tasy/status\",\n    \"/api/erp/soul-mv/status\"\n]\n\nDATASUS_ENDPOINTS = [\n    \"/api/datasus/rnds/status\",\n    \"/api/datasus/cnes/status\",\n    \"/api/datasus/sigtap/status\",\n    \"/api/datasus/esus-aps-ledi/status\"\n]\n\ndef test_erp_and_datasus_integration_error_rate_and_response_time():\n    total_requests = 0\n    total_errors = 0\n    max_response_time_ms = 0\n\n    def check_endpoints(endpoints, source_name):\n        nonlocal total_requests, total_errors, max_response_time_ms\n        for endpoint in endpoints:\n            url = f\"{BASE_URL}{endpoint}\"\n            try:\n                start = time.time()\n                resp = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n                elapsed_ms = (time.time() - start) * 1000\n                total_requests += 1\n                max_response_time_ms = max(max_response_time_ms, elapsed_ms)\n\n                # Check HTTP status 200 OK\n                assert resp.status_code == 200, f\"{source_name} endpoint {endpoint} returned status {resp.status_code}\"\n\n                # Basic content validation: expect JSON with a 'status' field = 'ok' or similar\n                json_data = resp.json()\n                status = json_data.get(\"status\") or json_data.get(\"connection_status\") or \"\"\n                assert status.lower() in (\"ok\", \"connected\", \"success\"), f\"{source_name} endpoint {endpoint} status not ok: {status}\"\n\n                # Response time under 500 ms\n                assert elapsed_ms < 500, f\"{source_name} endpoint {endpoint} response time {elapsed_ms:.2f}ms exceeds 500ms\"\n\n            except (requests.Timeout, requests.ConnectionError) as e:\n                total_requests += 1\n                total_errors += 1\n            except AssertionError as e:\n                total_errors += 1\n                raise\n            except Exception as e:\n                total_requests += 1\n                total_errors += 1\n                raise\n\n    try:\n        # Check ERP endpoints\n        check_endpoints(ERP_ENDPOINTS, \"ERP\")\n\n        # Check DATASUS endpoints\n        check_endpoints(DATASUS_ENDPOINTS, \"DATASUS\")\n\n        # Calculate error rate\n        if total_requests == 0:\n            raise AssertionError(\"No requests were made to ERP or DATASUS endpoints\")\n\n        error_rate = (total_errors / total_requests) * 100\n\n        assert error_rate < 1, f\"Error rate too high: {error_rate:.2f}% (Must be below 1%)\"\n        assert max_response_time_ms < 500, f\"Some requests exceeded max response time: {max_response_time_ms:.2f}ms (Must be below 500ms)\"\n    except AssertionError:\n        raise\n    except Exception as exc:\n        raise AssertionError(f\"An unexpected error occurred during ERP and DATASUS integration testing: {exc}\")\n\n\ntest_erp_and_datasus_integration_error_rate_and_response_time()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 64, in test_erp_and_datasus_integration_error_rate_and_response_time\n  File \"<string>\", line 41, in check_endpoints\nAssertionError: ERP endpoint /api/erp/philips-tasy/status returned status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.722Z",
    "modified": "2025-09-17T22:20:35.186Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "475358f6-50ed-4e57-b25b-26f103b29bfb",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC005-e sus aps integration configuration",
    "description": "Verify the complete integration with e-SUS APS via LEDI and DW PEC, including all 8 configuration sections and orchestration via MCP Server.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Authentication credentials (assuming test user exists)\nAUTH_USER = \"integration_tester\"\nAUTH_PASS = \"test_password\"\n\ndef authenticate():\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\"username\": AUTH_USER, \"password\": AUTH_PASS}\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    token = data.get(\"access_token\")\n    assert token, \"Authentication token not received\"\n    return token\n\ndef test_e_sus_aps_integration_configuration():\n    token = authenticate()\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    # 1. Verify presence and contents of all 8 configuration sections for e-SUS APS via LEDI and DW PEC\n\n    config_sections = [\n        \"general_settings\",\n        \"patient_data\",\n        \"clinical_data\",\n        \"health_team\",\n        \"appointments\",\n        \"procedures\",\n        \"medications\",\n        \"reports\"\n    ]\n\n    for section in config_sections:\n        url = f\"{BASE_URL}/api/esus-aps/configuration/{section}\"\n        resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to get config section {section}\"\n        data = resp.json()\n        assert isinstance(data, dict), f\"Config section {section} should be a dict\"\n        assert data != {}, f\"Config section {section} must not be empty\"\n\n    # 2. Test update on one configuration section with valid data\n\n    update_payload = {\n        \"enabled\": True,\n        \"parameters\": {\n            \"sync_interval_minutes\": 15,\n            \"retry_attempts\": 3\n        }\n    }\n    url = f\"{BASE_URL}/api/esus-aps/configuration/general_settings\"\n    resp = requests.put(url, headers=headers, json=update_payload, timeout=TIMEOUT)\n    assert resp.status_code in (200, 204), \"Failed to update general_settings\"\n\n    # 3. Validate orchestration via MCP Server endpoint - trigger orchestration and verify response\n\n    orchestration_url = f\"{BASE_URL}/api/mcp-server/orchestrate/esus-aps\"\n    resp = requests.post(orchestration_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 202, \"MCP Server orchestration trigger failed\"\n    orchestration_response = resp.json()\n    assert orchestration_response.get(\"status\") in [\"started\", \"queued\"], \"Orchestration not started or queued\"\n\n    orchestration_id = orchestration_response.get(\"orchestration_id\")\n    assert orchestration_id, \"Orchestration ID missing\"\n\n    # 4. Poll orchestration status until completion or timeout (max 60 seconds)\n\n    status_url = f\"{BASE_URL}/api/mcp-server/orchestrate/status/{orchestration_id}\"\n    start_time = time.time()\n    completed = False\n    while time.time() - start_time < 60:\n        resp = requests.get(status_url, headers=headers, timeout=TIMEOUT)\n        if resp.status_code != 200:\n            time.sleep(2)\n            continue\n        status_data = resp.json()\n        state = status_data.get(\"state\")\n        if state == \"completed\":\n            completed = True\n            break\n        elif state == \"failed\":\n            raise AssertionError(\"MCP Server orchestration failed\")\n        time.sleep(2)\n\n    assert completed, \"MCP Server orchestration did not complete in time\"\n\n    # 5. Validate integrations with e-SUS APS LEDI API endpoint data\n\n    ledi_url = f\"{BASE_URL}/api/esus-aps/ledi/status\"\n    resp = requests.get(ledi_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200, \"Failed to fetch LEDI API status\"\n    ledi_data = resp.json()\n    assert ledi_data.get(\"connected\") is True, \"LEDI API not connected\"\n    assert \"last_sync\" in ledi_data, \"LEDI API last_sync missing\"\n\n    # 6. Validate integration with DW PEC endpoint data\n\n    dwpec_url = f\"{BASE_URL}/api/esus-aps/dwpec/status\"\n    resp = requests.get(dwpec_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200, \"Failed to fetch DW PEC API status\"\n    dwpec_data = resp.json()\n    assert dwpec_data.get(\"connected\") is True, \"DW PEC API not connected\"\n    assert \"last_sync\" in dwpec_data, \"DW PEC API last_sync missing\"\n\n    # 7. Test error handling: Request non-existent configuration section\n\n    invalid_url = f\"{BASE_URL}/api/esus-aps/configuration/invalid_section_xyz\"\n    resp = requests.get(invalid_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 404, \"Invalid config section did not return 404\"\n\n    # 8. Security: Test access without token\n\n    resp = requests.get(f\"{BASE_URL}/api/esus-aps/configuration/general_settings\", timeout=TIMEOUT)\n    assert resp.status_code == 401, \"Unauthorized access did not return 401\"\n\n    # 9. Rate limiting: Send burst of requests to configuration endpoint, expect 429 or success but no failures\n\n    success_count = 0\n    rate_limit_triggered = False\n    for _ in range(20):\n        r = requests.get(f\"{BASE_URL}/api/esus-aps/configuration/general_settings\", headers=headers, timeout=TIMEOUT)\n        if r.status_code == 429:\n            rate_limit_triggered = True\n            break\n        elif r.status_code == 200:\n            success_count += 1\n        else:\n            raise AssertionError(f\"Unexpected status code during rate limit test: {r.status_code}\")\n\n    assert success_count > 0, \"No successful requests in rate limit test\"\n    # Rate limiting may or may not be enforced depending on config; accept if triggered or not\n    # Just ensure no 5xx or unexpected errors\n\n    # 10. Data synchronization test: Trigger synchronization and verify last_sync timestamps update\n\n    sync_trigger_url = f\"{BASE_URL}/api/esus-aps/synchronize\"\n    resp = requests.post(sync_trigger_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 202, \"Failed to trigger e-SUS APS synchronization\"\n\n    # Wait some seconds for sync to process\n    time.sleep(5)\n\n    # Confirm last_sync updated for LEDI and DW PEC\n\n    resp_ledi = requests.get(ledi_url, headers=headers, timeout=TIMEOUT)\n    resp_dwpec = requests.get(dwpec_url, headers=headers, timeout=TIMEOUT)\n    assert resp_ledi.status_code == 200 and resp_dwpec.status_code == 200\n\n    ledi_after = resp_ledi.json()\n    dwpec_after = resp_dwpec.json()\n    assert ledi_after.get(\"last_sync\"), \"LEDI last_sync missing after sync\"\n    assert dwpec_after.get(\"last_sync\"), \"DW PEC last_sync missing after sync\"\n\n    # 11. Validate audit log entry for orchestration operation\n\n    audit_url = f\"{BASE_URL}/api/audit-logs?operation=mcp-orchestration&orchestration_id={orchestration_id}\"\n    resp = requests.get(audit_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200, \"Failed to fetch audit logs\"\n    logs = resp.json()\n    assert isinstance(logs, list), \"Audit logs response should be a list\"\n    assert any(log.get(\"orchestration_id\") == orchestration_id for log in logs), \"Audit log entry for orchestration missing\"\n\ntest_e_sus_aps_integration_configuration()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 172, in <module>\n  File \"<string>\", line 23, in test_e_sus_aps_integration_configuration\n  File \"<string>\", line 16, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.727Z",
    "modified": "2025-09-17T22:20:33.940Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "4370b743-c899-4ca0-882a-dc6e703d2079",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC006-epidemic alert notifications",
    "description": "Check that the epidemic alert system sends automatic notifications correctly and displays risk maps and indicators by neighborhood according to the user's profile.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef authenticate_user(username: str, password: str) -> str:\n    \"\"\"\n    Authenticate user and return JWT token.\n    \"\"\"\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\n        \"username\": username,\n        \"password\": password\n    }\n    response = requests.post(url, json=payload, timeout=TIMEOUT)\n    response.raise_for_status()\n    token = response.json().get(\"access_token\")\n    assert token, \"Authentication failed, no access token received.\"\n    return token\n\ndef create_test_user():\n    \"\"\"\n    Create a demo user using Supabase edge function 'create-demo-user'.\n    Returns the user's credentials and user id.\n    \"\"\"\n    url = f\"{BASE_URL}/api/supabase/create-demo-user\"\n    response = requests.post(url, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    user_id = data.get(\"id\")\n    username = data.get(\"username\")\n    password = data.get(\"password\")\n    assert user_id and username and password, \"User creation failed or incomplete data.\"\n    return user_id, username, password\n\ndef delete_test_user(user_id: str, token: str):\n    \"\"\"\n    Delete the created test user by user_id using admin endpoint.\n    \"\"\"\n    url = f\"{BASE_URL}/api/users/{user_id}\"\n    headers = {\n        **HEADERS,\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    response = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    assert response.status_code in (200, 204), f\"Failed to delete test user: {response.text}\"\n\ndef get_user_profile_alerts(token: str):\n    \"\"\"\n    Fetch epidemic alerts, risk maps, and neighborhood indicators for authenticated user.\n    \"\"\"\n    url = f\"{BASE_URL}/api/epidemic/alerts\"\n    headers = {\n        **HEADERS,\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef test_epidemic_alert_notifications():\n    \"\"\"\n    Test the epidemic alert system:\n    - Authenticate user (create demo user if needed)\n    - Validate automatic notifications are sent\n    - Validate risk maps and indicators by neighborhood per user profile\n    - Authentication using Supabase edge function\n    - Test error handling for invalid token\n    - Check response performance (response time < 2 seconds)\n    \"\"\"\n    user_id = None\n    token = None\n    try:\n        # Create demo user and get credentials\n        user_id, username, password = create_test_user()\n\n        # Authenticate to get JWT token\n        token = authenticate_user(username, password)\n\n        # Check epidemic alerts endpoint with valid token\n        start_time = time.time()\n        response = get_user_profile_alerts(token)\n        duration = time.time() - start_time\n\n        assert response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n        data = response.json()\n\n        # Validate structure of response (risk maps, notifications, indicators)\n        assert \"notifications\" in data, \"Missing 'notifications' in response\"\n        assert isinstance(data[\"notifications\"], list), \"'notifications' should be a list\"\n\n        assert \"risk_maps\" in data, \"Missing 'risk_maps' in response\"\n        assert isinstance(data[\"risk_maps\"], dict), \"'risk_maps' should be a dict\"\n\n        assert \"neighborhood_indicators\" in data, \"Missing 'neighborhood_indicators' in response\"\n        assert isinstance(data[\"neighborhood_indicators\"], list), \"'neighborhood_indicators' should be a list\"\n\n        # Check notifications have expected fields\n        for notif in data[\"notifications\"]:\n            assert \"id\" in notif and \"message\" in notif and \"date\" in notif, \"Notification missing expected fields\"\n\n        # Check risk_maps contains keys representing neighborhoods or areas\n        assert any(isinstance(v, dict) for v in data[\"risk_maps\"].values()), \"Risk maps data malformed\"\n\n        # Check response time performance (less than 2 seconds)\n        assert duration < 2, f\"API response time too high: {duration}s\"\n\n        # Test with invalid token: expect 401 Unauthorized\n        invalid_headers = {\n            **HEADERS,\n            \"Authorization\": \"Bearer invalid.token.here\"\n        }\n        invalid_resp = requests.get(f\"{BASE_URL}/api/epidemic/alerts\", headers=invalid_headers, timeout=TIMEOUT)\n        assert invalid_resp.status_code == 401, f\"Expected 401 for invalid token, got {invalid_resp.status_code}\"\n\n    finally:\n        # Cleanup: Delete test user if created and token available\n        if user_id and token:\n            try:\n                delete_test_user(user_id, token)\n            except Exception as e:\n                print(f\"Warning: failed to delete test user: {e}\")\n\ntest_epidemic_alert_notifications()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 127, in <module>\n  File \"<string>\", line 78, in test_epidemic_alert_notifications\n  File \"<string>\", line 32, in create_test_user\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/api/supabase/create-demo-user\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.732Z",
    "modified": "2025-09-17T22:20:35.172Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "5a30915a-aeb4-42ce-9396-d4d82fb44885",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC007-navigation sidebar responsiveness",
    "description": "Test the responsive navigation system including dynamic sidebar, navbar, and specialized layouts for different user profiles.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Sample user profiles with expected layout indicators for validation\nUSER_PROFILES = [\n    {\n        \"role\": \"Gestor\",\n        \"auth_payload\": {\"email\": \"gestor@example.com\", \"password\": \"GestorPass123\"},\n        \"expected_redirect\": \"/dashboard/municipal\",\n        \"sidebar_indicator\": \"Municipal KPIs\",\n        \"navbar_indicator\": \"Gestor Menu\",\n    },\n    {\n        \"role\": \"Hospital\",\n        \"auth_payload\": {\"email\": \"hospital@example.com\", \"password\": \"HospitalPass123\"},\n        \"expected_redirect\": \"/dashboard/hospital\",\n        \"sidebar_indicator\": \"Gestão de Leitos\",\n        \"navbar_indicator\": \"Hospital Menu\",\n    },\n    {\n        \"role\": \"Médico\",\n        \"auth_payload\": {\"email\": \"medico@example.com\", \"password\": \"MedicoPass123\"},\n        \"expected_redirect\": \"/dashboard/medico\",\n        \"sidebar_indicator\": \"Protocolos Clínicos\",\n        \"navbar_indicator\": \"Médico Menu\",\n    },\n    {\n        \"role\": \"Paciente\",\n        \"auth_payload\": {\"email\": \"paciente@example.com\", \"password\": \"PacientePass123\"},\n        \"expected_redirect\": \"/dashboard/paciente\",\n        \"sidebar_indicator\": \"Histórico Médico\",\n        \"navbar_indicator\": \"Paciente Menu\",\n    },\n]\n\ndef test_navigation_sidebar_responsiveness():\n    session = requests.Session()\n    session.headers.update({\"Content-Type\": \"application/json\"})\n\n    try:\n        for profile in USER_PROFILES:\n            # Authenticate user and get JWT token\n            auth_resp = session.post(\n                f\"{BASE_URL}/auth/login\",\n                json=profile[\"auth_payload\"],\n                timeout=TIMEOUT\n            )\n            assert auth_resp.status_code == 200, f\"Auth failed for {profile['role']}\"\n            auth_data = auth_resp.json()\n            token = auth_data.get(\"access_token\")\n            assert token, f\"No token received for {profile['role']}\"\n\n            # Update session headers with Authorization for subsequent requests\n            session.headers.update({\"Authorization\": f\"Bearer {token}\"})\n\n            # Access profile switch endpoint to emulate dynamic profile switching\n            switch_resp = session.post(\n                f\"{BASE_URL}/auth/switch-profile\",\n                json={\"role\": profile[\"role\"]},\n                timeout=TIMEOUT\n            )\n            assert switch_resp.status_code == 200, f\"Profile switch failed for {profile['role']}\"\n            switch_data = switch_resp.json()\n            \n            # Verify redirection URL for dashboard based on profile\n            redirect_url = switch_data.get(\"redirect_url\")\n            assert redirect_url == profile[\"expected_redirect\"], \\\n                f\"Redirect URL mismatch for {profile['role']}: expected {profile['expected_redirect']}, got {redirect_url}\"\n\n            # Access the dashboard page for the profile\n            dash_resp = session.get(f\"{BASE_URL}{redirect_url}\", timeout=TIMEOUT)\n            assert dash_resp.status_code == 200, f\"Dashboard access failed for {profile['role']}\"\n\n            dash_json = dash_resp.json()\n\n            # Validate presence of dynamic sidebar data appropriate for profile\n            sidebar = dash_json.get(\"sidebar\")\n            assert sidebar, f\"No sidebar data for {profile['role']}\"\n            assert profile[\"sidebar_indicator\"] in sidebar.get(\"content\", \"\"), \\\n                f\"Sidebar content mismatch for {profile['role']}\"\n\n            # Validate presence of navbar info appropriate for profile\n            navbar = dash_json.get(\"navbar\")\n            assert navbar, f\"No navbar data for {profile['role']}\"\n            assert profile[\"navbar_indicator\"] in navbar.get(\"content\", \"\"), \\\n                f\"Navbar content mismatch for {profile['role']}\"\n\n            # Validate specialized layout configuration for the profile\n            layout = dash_json.get(\"layout\")\n            assert layout, f\"No layout data for {profile['role']}\"\n            assert layout.get(\"profile\") == profile[\"role\"], \\\n                f\"Layout profile mismatch for {profile['role']}\"\n\n            # Additional backend checks for responsiveness: quick response time\n            response_time = dash_resp.elapsed.total_seconds()\n            assert response_time < 2, f\"Dashboard response time too high for {profile['role']}: {response_time}s\"\n\n            # Emulate rapid profile switching to test dynamic behavior\n            for switch_role in USER_PROFILES:\n                if switch_role[\"role\"] == profile[\"role\"]:\n                    continue\n                sr_resp = session.post(\n                    f\"{BASE_URL}/auth/switch-profile\",\n                    json={\"role\": switch_role[\"role\"]},\n                    timeout=TIMEOUT\n                )\n                assert sr_resp.status_code == 200, f\"Rapid switch failed from {profile['role']} to {switch_role['role']}\"\n\n            # Clear Authorization header for next profile test\n            session.headers.pop(\"Authorization\", None)\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n\n\ntest_navigation_sidebar_responsiveness()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 119, in <module>\n  File \"<string>\", line 51, in test_navigation_sidebar_responsiveness\nAssertionError: Auth failed for Gestor\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.737Z",
    "modified": "2025-09-17T22:21:21.755Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "cdce0946-1208-408c-a8dd-39733d577fe9",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC008-telemedicine session management",
    "description": "Validate the telemedicine system's ability to manage consultation sessions and display the modal for teleconsultations properly.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30  # seconds\n\n# Assume authentication token retrieval function (mocked/stubbed)\ndef get_auth_token():\n    # In real scenario, authenticate and get JWT token\n    # Here, return a placeholder token\n    return \"Bearer example-valid-jwt-token-for-testing\"\n\ndef create_telemedicine_session(auth_token, payload):\n    url = f\"{BASE_URL}/api/telemedicine/sessions\"\n    headers = {\n        \"Authorization\": auth_token,\n        \"Content-Type\": \"application/json\"\n    }\n    response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef get_telemedicine_session(auth_token, session_id):\n    url = f\"{BASE_URL}/api/telemedicine/sessions/{session_id}\"\n    headers = {\n        \"Authorization\": auth_token\n    }\n    response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef update_telemedicine_session(auth_token, session_id, payload):\n    url = f\"{BASE_URL}/api/telemedicine/sessions/{session_id}\"\n    headers = {\n        \"Authorization\": auth_token,\n        \"Content-Type\": \"application/json\"\n    }\n    response = requests.put(url, json=payload, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef delete_telemedicine_session(auth_token, session_id):\n    url = f\"{BASE_URL}/api/telemedicine/sessions/{session_id}\"\n    headers = {\n        \"Authorization\": auth_token\n    }\n    response = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    return response\n\ndef test_telemedicine_session_management():\n    auth_token = get_auth_token()\n    assert auth_token.startswith(\"Bearer \"), \"Invalid auth token format\"\n\n    # Create a new telemedicine session resource\n    session_payload = {\n        \"patientId\": str(uuid.uuid4()),      # Simulate a patient id\n        \"doctorId\": str(uuid.uuid4()),       # Simulate a doctor id\n        \"scheduledTime\": int(time.time()) + 3600,  # 1 hour in future\n        \"durationMinutes\": 30,\n        \"reason\": \"Routine follow-up consultation\"\n    }\n\n    # Create session\n    create_resp = create_telemedicine_session(auth_token, session_payload)\n    assert create_resp.status_code == 201, f\"Failed to create session: {create_resp.status_code} {create_resp.text}\"\n    session_data = create_resp.json()\n    session_id = session_data.get(\"id\")\n    assert session_id, \"Response missing session id\"\n\n    try:\n        # Retrieve session to validate it was saved correctly\n        get_resp = get_telemedicine_session(auth_token, session_id)\n        assert get_resp.status_code == 200, f\"Failed to get session: {get_resp.status_code} {get_resp.text}\"\n        get_data = get_resp.json()\n        assert get_data[\"id\"] == session_id\n        assert get_data[\"patientId\"] == session_payload[\"patientId\"]\n        assert get_data[\"doctorId\"] == session_payload[\"doctorId\"]\n        assert get_data[\"durationMinutes\"] == session_payload[\"durationMinutes\"]\n        assert get_data[\"reason\"] == session_payload[\"reason\"]\n\n        # Update the session: simulate changing duration and reason\n        update_payload = {\n            \"durationMinutes\": 45,\n            \"reason\": \"Extended consultation for medication review\"\n        }\n        update_resp = update_telemedicine_session(auth_token, session_id, update_payload)\n        assert update_resp.status_code == 200, f\"Failed to update session: {update_resp.status_code} {update_resp.text}\"\n        updated_data = update_resp.json()\n        assert updated_data[\"durationMinutes\"] == update_payload[\"durationMinutes\"]\n        assert updated_data[\"reason\"] == update_payload[\"reason\"]\n\n        # Test modal display representation endpoint (simulate)\n        # Assume there's an endpoint to fetch modal data for teleconsultation\n        modal_url = f\"{BASE_URL}/api/telemedicine/sessions/{session_id}/modal\"\n        modal_resp = requests.get(modal_url, headers={\"Authorization\": auth_token}, timeout=TIMEOUT)\n\n        assert modal_resp.status_code == 200, f\"Failed to get telemedicine modal data: {modal_resp.status_code} {modal_resp.text}\"\n        modal_data = modal_resp.json()\n\n        # Validate modal required keys exist and types\n        required_keys = [\"sessionId\", \"patientInfo\", \"doctorInfo\", \"scheduledTime\", \"status\", \"videoCallUrl\"]\n        for key in required_keys:\n            assert key in modal_data, f\"Modal response missing key: {key}\"\n\n        assert modal_data[\"sessionId\"] == session_id\n        assert isinstance(modal_data[\"patientInfo\"], dict)\n        assert isinstance(modal_data[\"doctorInfo\"], dict)\n        assert isinstance(modal_data[\"scheduledTime\"], int)\n        assert modal_data[\"status\"] in [\"scheduled\", \"ongoing\", \"completed\", \"cancelled\"]\n        assert isinstance(modal_data[\"videoCallUrl\"], str) and modal_data[\"videoCallUrl\"].startswith(\"https://\")\n\n        # Negative test: Attempt to get a non-existent session (error handling)\n        fake_session_id = str(uuid.uuid4())\n        not_found_resp = get_telemedicine_session(auth_token, fake_session_id)\n        assert not_found_resp.status_code == 404, f\"Expected 404 for non-existent session but got {not_found_resp.status_code}\"\n\n        # Rate limiting test: Send rapid multiple requests and expect 429 or normal response\n        rapid_responses = []\n        for _ in range(5):\n            r = get_telemedicine_session(auth_token, session_id)\n            rapid_responses.append(r.status_code)\n        assert all(code in (200, 429) for code in rapid_responses), \"Unexpected status code during rate limiting test\"\n\n    finally:\n        # Clean up: delete the created session\n        del_resp = delete_telemedicine_session(auth_token, session_id)\n        assert del_resp.status_code in (200, 204), f\"Failed to delete session: {del_resp.status_code} {del_resp.text}\"\n\ntest_telemedicine_session_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 127, in <module>\n  File \"<string>\", line 63, in test_telemedicine_session_management\nAssertionError: Failed to create session: 404 \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.743Z",
    "modified": "2025-09-17T22:20:38.722Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "c7ed198f-f012-48e3-b0ae-5668adc2f913",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC009-ai analytics predictive insights",
    "description": "Verify that the AI analytics dashboard provides accurate predictive analysis and advanced insights based on health data.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef get_jwt_token():\n    auth_url = f\"{BASE_URL}/auth/login\"\n    auth_payload = {\n        \"email\": \"demo@saudepublica.br\",\n        \"password\": \"DemoPass123!\"\n    }\n    resp = requests.post(auth_url, json=auth_payload, timeout=TIMEOUT)\n    if resp.status_code == 404:\n        assert False, f\"Authentication endpoint not found at {auth_url}. Please verify the auth API implementation.\"\n    resp.raise_for_status()\n    return resp.json().get(\"access_token\")\n\ndef create_demo_health_data(token):\n    url = f\"{BASE_URL}/health-data\"\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n    payload = {\n        \"patientId\": \"demo-patient-001\",\n        \"metrics\": {\n            \"heartRate\": 72,\n            \"bloodPressure\": \"120/80\",\n            \"glucoseLevel\": 90,\n            \"oxygenSaturation\": 98\n        },\n        \"timestamp\": int(time.time())\n    }\n    resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json().get(\"id\")\n\ndef delete_health_data(resource_id, token):\n    url = f\"{BASE_URL}/health-data/{resource_id}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    if resp.status_code not in (204, 200, 404):\n        resp.raise_for_status()\n\ndef test_ai_analytics_predictive_insights():\n    token = get_jwt_token()\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Create sample health data to trigger predictive analytics\n    resource_id = create_demo_health_data(token)\n\n    try:\n        # Call the AI analytics dashboard predictive insights endpoint\n        url = f\"{BASE_URL}/analytics/ai/predictive-insights\"\n        params = {\"patientId\": \"demo-patient-001\"}\n        resp = requests.get(url, headers=headers, params=params, timeout=TIMEOUT)\n\n        # Validate response status code\n        assert resp.status_code == 200, f\"Expected 200 OK, got {resp.status_code}\"\n\n        data = resp.json()\n\n        # Validate presence of required fields\n        assert \"predictiveAnalysis\" in data, \"'predictiveAnalysis' missing in response\"\n        assert \"advancedInsights\" in data, \"'advancedInsights' missing in response\"\n\n        predictive = data[\"predictiveAnalysis\"]\n        insights = data[\"advancedInsights\"]\n\n        # Check predictiveAnalysis structure and reasonable values\n        assert isinstance(predictive, dict), \"'predictiveAnalysis' should be a dict\"\n        for key in [\"riskScore\", \"trend\", \"recommendations\"]:\n            assert key in predictive, f\"'{key}' missing in predictiveAnalysis\"\n        assert 0 <= predictive[\"riskScore\"] <= 1, \"'riskScore' should be between 0 and 1\"\n        assert isinstance(predictive[\"recommendations\"], list), \"'recommendations' should be a list\"\n        assert len(predictive[\"recommendations\"]) > 0, \"'recommendations' should not be empty\"\n\n        # Check advancedInsights structure\n        assert isinstance(insights, dict), \"'advancedInsights' should be a dict\"\n        assert \"summary\" in insights, \"'summary' missing in advancedInsights\"\n        assert \"detailedMetrics\" in insights, \"'detailedMetrics' missing in advancedInsights\"\n        assert isinstance(insights[\"detailedMetrics\"], dict), \"'detailedMetrics' should be a dict\"\n\n        # Validate that detailedMetrics keys correspond to input health metrics (example)\n        expected_metrics = {\"heartRate\", \"bloodPressure\", \"glucoseLevel\", \"oxygenSaturation\"}\n        metric_keys = set(insights[\"detailedMetrics\"].keys())\n        assert expected_metrics.issubset(metric_keys), \"Some expected detailedMetrics keys are missing\"\n\n        # Additional sanity checks on values (example)\n        hr = insights[\"detailedMetrics\"][\"heartRate\"]\n        assert isinstance(hr, (int, float)) and hr > 0, \"Invalid heartRate in detailedMetrics\"\n\n        # Check response headers for security\n        assert \"content-security-policy\" in resp.headers or \"Content-Security-Policy\" in resp.headers\n\n    finally:\n        # Clean up created health data\n        delete_health_data(resource_id, token)\n\ntest_ai_analytics_predictive_insights()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 44, in test_ai_analytics_predictive_insights\n  File \"<string>\", line 15, in get_jwt_token\nAssertionError: Authentication endpoint not found at http://localhost:8080/auth/login. Please verify the auth API implementation.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.748Z",
    "modified": "2025-09-17T22:20:58.774Z"
  },
  {
    "projectId": "a9146b68-0b69-40c9-9048-a56bf78b33e1",
    "testId": "8d96d398-807d-4a47-acc1-0345de8c17e9",
    "userId": "d4785458-7051-70b8-17ae-203b0b7807ec",
    "title": "TC010-internationalization language support",
    "description": "Ensure the system supports full internationalization with correct translations and functionality in Portuguese, English, Spanish, and French.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\"\n}\n\ndef test_internationalization_language_support():\n    \"\"\"\n    Test the internationalization system for PT, EN, ES, FR languages.\n    It will check REST API and Supabase authentication endpoints that support language param,\n    verify translations keys and also test selecting dashboards with language headers.\n    \"\"\"\n\n    languages = {\n        \"pt\": \"Português\",\n        \"en\": \"English\",\n        \"es\": \"Español\",\n        \"fr\": \"Français\"\n    }\n\n    # 1. Test authentication endpoint supports language param and returns messages in the selected language\n    auth_url = f\"{BASE_URL}/auth/login\"\n    # Dummy credentials for test; if auth service requires actual, adapt as needed.\n    credentials = {\"email\": \"testuser@example.com\", \"password\": \"TestPass123!\"}\n\n    for lang_code, lang_name in languages.items():\n        try:\n            # Sending Accept-Language header to test backend language recognition\n            headers = HEADERS.copy()\n            headers[\"Accept-Language\"] = lang_code\n\n            # POST login\n            resp = requests.post(auth_url, json=credentials, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code in (200, 401), f\"Unexpected status {resp.status_code} on login with lang {lang_code}\"\n            resp_json = resp.json()\n\n            # Check that response message (if any) contains expected language keywords for validation\n            # We use a simple heuristic: check known common messages or welcome text translations\n            messages = [\n                # Common login errors translations:\n                {\"pt\": \"senha\", \"en\": \"password\", \"es\": \"contraseña\", \"fr\": \"mot de passe\"},\n            ]\n\n            # Check at least one keyword from messages for each language is found in response texts (keys and values)\n            matching = any(\n                (lang_code in messages[0] and messages[0][lang_code].lower() in str(resp_json).lower())\n                for _ in [0]\n            )\n            # If 401 unauthorized, message usually contain the password word in their language\n            assert matching or resp.status_code == 200, f\"Response does not contain expected language elements for {lang_name}\"\n\n        except Exception as e:\n            raise AssertionError(f\"Auth endpoint language test failed for {lang_name}: {str(e)}\")\n\n    # 2. Test localization endpoint or public translations files availability (simulate fetching common translation resource)\n    # Assuming an endpoint convention: GET /locales/{lang}/common.json or similar\n    for lang_code, lang_name in languages.items():\n        try:\n            url = f\"{BASE_URL}/locales/{lang_code}/common.json\"\n            r = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n            assert r.status_code == 200, f\"Failed to get translations JSON for language {lang_name}\"\n            json_data = r.json()\n            # Basic validation: check some keys known in translations e.g. \"welcome\", \"logout\"\n            expected_keys = [\"welcome\", \"logout\", \"login\", \"dashboard\"]\n            missing_keys = [k for k in expected_keys if k not in json_data]\n            assert not missing_keys, f\"Missing keys in {lang_name} translation JSON: {missing_keys}\"\n\n        except Exception as e:\n            raise AssertionError(f\"Translations file test failed for {lang_name}: {str(e)}\")\n\n    # 3. Test dashboard redirect with Accept-Language header for different profiles returns content in right language\n    # Step 1: Authenticate and get JWT token for a test user with multi-profile (simulate or create user)\n    auth_login_url = f\"{BASE_URL}/auth/login\"\n    user_credentials = {\"email\": \"testuser@example.com\", \"password\": \"TestPass123!\"}\n\n    token = None\n    try:\n        res = requests.post(auth_login_url, json=user_credentials, headers=HEADERS, timeout=TIMEOUT)\n        assert res.status_code == 200, \"Failed to login test user for dashboard test\"\n        data = res.json()\n        token = data.get(\"access_token\") or data.get(\"token\")\n        assert token, \"No access token received\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication failed: {str(e)}\")\n\n    # Profiles to test dashboard redirection and language content\n    profiles = {\n        \"gestor\": \"/dashboard/municipal\",\n        \"hospital\": \"/dashboard/hospital\",\n        \"medico\": \"/dashboard/medical\",\n        \"paciente\": \"/dashboard/patient\"\n    }\n\n    headers_auth = HEADERS.copy()\n    headers_auth[\"Authorization\"] = f\"Bearer {token}\"\n\n    for lang_code, lang_name in languages.items():\n        for profile, endpoint in profiles.items():\n            try:\n                headers_profile = headers_auth.copy()\n                headers_profile[\"Accept-Language\"] = lang_code\n\n                url = f\"{BASE_URL}{endpoint}\"\n                resp = requests.get(url, headers=headers_profile, timeout=TIMEOUT)\n                assert resp.status_code == 200, f\"Dashboard {profile} failed with status {resp.status_code} for language {lang_name}\"\n                content = resp.text.lower()\n\n                # Check that content includes translated keywords typical for dashboards\n                # Heuristic checks for presence of translated role name or dashboard keyword\n                expected_strings = {\n                    \"pt\": [\"dashboard\", \"kpi\", \"gestor\", \"hospital\", \"médico\", \"paciente\"],\n                    \"en\": [\"dashboard\", \"kpi\", \"manager\", \"hospital\", \"doctor\", \"patient\"],\n                    \"es\": [\"tablero\", \"kpi\", \"gestor\", \"hospital\", \"médico\", \"paciente\"],\n                    \"fr\": [\"tableau\", \"kpi\", \"gestionnaire\", \"hôpital\", \"médecin\", \"patient\"]\n                }\n                check_strings = expected_strings.get(lang_code, [])\n                found = any(s in content for s in check_strings)\n                assert found, f\"Dashboard content for profile {profile} missing translated keywords in {lang_name}\"\n\n            except Exception as e:\n                raise AssertionError(f\"Dashboard language test failed for profile {profile} in {lang_name}: {str(e)}\")\n\n    # 4. Test edge functions and real-time subscriptions language support (simulate call to edge function create-demo-user with language header)\n    try:\n        edge_url = f\"{BASE_URL}/edge-functions/create-demo-user\"\n        for lang_code, lang_name in languages.items():\n            headers_edge = HEADERS.copy()\n            headers_edge[\"Accept-Language\"] = lang_code\n            resp = requests.post(edge_url, headers=headers_edge, timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Edge function create-demo-user failed for language {lang_name}\"\n            data = resp.json()\n            # Check that any message in response is in the expected language (heuristic)\n            msg = \"message\"\n            if msg in data:\n                msg_text = data[msg].lower()\n                # Basic keywords check\n                keywords = {\n                    \"pt\": [\"usuário\", \"criado\"],\n                    \"en\": [\"user\", \"created\"],\n                    \"es\": [\"usuario\", \"creado\"],\n                    \"fr\": [\"utilisateur\", \"créé\"]\n                }\n                key_checks = keywords.get(lang_code, [])\n                found_key = any(k in msg_text for k in key_checks)\n                assert found_key, f\"Edge function message not localized properly for {lang_name}\"\n\n    except Exception as e:\n        raise AssertionError(f\"Edge function internationalization test failed: {str(e)}\")\n\n    # 5. Rate limiting and error handling tests with language headers\n    # Send repeated invalid requests with Accept-Language header and check error messages are localized\n    try:\n        invalid_url = f\"{BASE_URL}/auth/login\"\n        for lang_code, lang_name in languages.items():\n            headers_invalid = HEADERS.copy()\n            headers_invalid[\"Accept-Language\"] = lang_code\n            payload = {\"email\": \"invalid\", \"password\": \"\"}\n            resp = requests.post(invalid_url, json=payload, headers=headers_invalid, timeout=TIMEOUT)\n            assert resp.status_code in (400,401), f\"Expected 400 or 401 on invalid login for {lang_name}\"\n            j = resp.json()\n            # Check error message localized heuristically\n            err_msg = str(j).lower()\n            error_keywords = {\n                \"pt\": [\"inválido\", \"erro\", \"senha\", \"email\"],\n                \"en\": [\"invalid\", \"error\", \"password\", \"email\"],\n                \"es\": [\"inválido\", \"error\", \"contraseña\", \"correo\"],\n                \"fr\": [\"invalide\", \"erreur\", \"mot de passe\", \"email\"]\n            }\n            assert any(k in err_msg for k in error_keywords.get(lang_code, [])), f\"Error message not localized for {lang_name}\"\n\n    except Exception as e:\n        raise AssertionError(f\"Error handling internationalization test failed: {str(e)}\")\n\n    # 6. Check that DATASUS external endpoints receive Accept-Language and respond correctly (simulate a simple GET with header)\n    datasus_endpoints = [\n        \"/datasus/rnds\",\n        \"/datasus/cnes\",\n        \"/datasus/sigtap\",\n        \"/datasus/esus-aps/ledi\"\n    ]\n\n    for lang_code, lang_name in languages.items():\n        headers_ds = HEADERS.copy()\n        headers_ds[\"Accept-Language\"] = lang_code\n        for path in datasus_endpoints:\n            try:\n                url = f\"{BASE_URL}{path}\"\n                resp = requests.get(url, headers=headers_ds, timeout=TIMEOUT)\n                assert resp.status_code == 200, f\"DATASUS endpoint {path} failed for language {lang_name}\"\n                json_data = resp.json()\n                # Basic validation: keys present (simulate expected keys)\n                expected_keys = {\n                    \"/datasus/rnds\": [\"patients\", \"last_update\"],\n                    \"/datasus/cnes\": [\"facilities\", \"region\"],\n                    \"/datasus/sigtap\": [\"procedures\", \"codes\"],\n                    \"/datasus/esus-aps/ledi\": [\"configurations\", \"status\"]\n                }\n                keys_needed = expected_keys.get(path, [])\n                missing_keys = [k for k in keys_needed if k not in json_data]\n                assert not missing_keys, f\"Missing keys in {path} response for {lang_name}: {missing_keys}\"\n            except Exception as e:\n                raise AssertionError(f\"DATASUS endpoint {path} internationalization test failed for {lang_name}: {str(e)}\")\n\n    print(\"Test TC010 internationalization language support passed successfully.\")\n\ntest_internationalization_language_support()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 37, in test_internationalization_language_support\nAssertionError: Unexpected status 404 on login with lang pt\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 209, in <module>\n  File \"<string>\", line 56, in test_internationalization_language_support\nAssertionError: Auth endpoint language test failed for Português: Unexpected status 404 on login with lang pt\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-17T22:19:48.753Z",
    "modified": "2025-09-17T22:20:41.279Z"
  }
]
